{"version":3,"sources":["../node_modules/brace/mode/livescript.js"],"names":["ace","define","acequire","exports","module","Range","MatchingBraceOutdent","this","checkOutdent","line","input","test","autoOutdent","doc","row","match","getLine","column","length","openBracePos","findMatchingBracket","indent","$getIndent","replace","call","prototype","identifier","LiveScriptMode","keywordend","stringfill","Mode","superclass","indenter","sub","sup","fun","constructor","extended","extend$","obj","src","own","hasOwnProperty","key","import$","displayName","that","$tokenizer","Rules","$outdent","$id","RegExp","getNextLineIndent","state","tab","tokens","getLineTokens","type","lineCommentStart","blockComment","start","end","ref$","defaultToken","token","regex","next","heregex","comment","qdoc","qqdoc","qstring","qqstring","js","words"],"mappings":"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MAAO,aACPC,MAAO,MACPC,KAAM,QACL,CACDF,MAAO,aACPC,MAAO,MACPC,KAAM,SACL,CACDF,MAAO,SACPC,MAAO,IACPC,KAAM,WACL,CACDF,MAAO,SACPC,MAAO,IACPC,KAAM,YACL,CACDF,MAAO,SACPC,MAAO,IACPC,KAAM,MACL,CACDF,MAAO,SACPC,MAAO,OACPC,KAAM,SACL,CACDF,MAAO,eACPC,MAAO,KACPC,KAAM,WACL,CACDF,MAAO,cACPC,MAAO,OACPC,KAAM,WACL,CACDF,MAAO,UACPC,MAAO,OACN,CACDD,MAAO,eACPC,MAAO,kHACPC,KAAM,OACL,CACDF,MAAO,mBACPC,MAAO,+JACN,CACDD,MAAO,SACPC,MAAO,SACN,CACDD,MAAO,SACPC,MAAO,UACPC,KAAM,OACL,CACDF,MAAO,mBACPC,MAAO,kBACN,CACDD,MAAO,OACPC,MAAO,SAETE,QAAS,CAAC,CACRH,MAAO,eACPC,MAAO,qBACPC,KAAM,SACL,CACDF,MAAO,eACPC,MAAO,UACN,CACDD,MAAO,gBACPC,MAAO,gBACN,CACDF,aAAc,iBAEhBpB,IAAK,CAAC,CACJqB,MAAO,mBACPC,MAAO,WACN,CACDD,MAAO,aACPC,MAAOvC,EACPwC,KAAM,SACL,CACDF,MAAO,OACPC,MAAO,GACPC,KAAM,UAERE,QAAS,CAAC,CACRJ,MAAO,cACPC,MAAO,UACPC,KAAM,SACL,CACDH,aAAc,gBAEhBM,KAAM,CAAC,CACLL,MAAO,SACPC,MAAO,SACPC,KAAM,OACLrC,GACHyC,MAAO,CAAC,CACNN,MAAO,SACPC,MAAO,SACPC,KAAM,OACLrC,GACH0C,QAAS,CAAC,CACRP,MAAO,SACPC,MAAO,gCACPC,KAAM,OACLrC,GACH2C,SAAU,CAAC,CACTR,MAAO,SACPC,MAAO,gCACPC,KAAM,OACLrC,GACH4C,GAAI,CAAC,CACHT,MAAO,SACPC,MAAO,gCACPC,KAAM,OACLrC,GACH6C,MAAO,CAAC,CACNV,MAAO,SACPC,MAAO,UACPC,KAAM,OACLrC","file":"static/js/77.e8dc6f06.chunk.js","sourcesContent":["ace.define(\"ace/mode/matching_brace_outdent\", [\"require\", \"exports\", \"module\", \"ace/range\"], function (acequire, exports, module) {\n  \"use strict\";\n\n  var Range = acequire(\"../range\").Range;\n\n  var MatchingBraceOutdent = function MatchingBraceOutdent() {};\n\n  (function () {\n    this.checkOutdent = function (line, input) {\n      if (!/^\\s+$/.test(line)) return false;\n      return /^\\s*\\}/.test(input);\n    };\n\n    this.autoOutdent = function (doc, row) {\n      var line = doc.getLine(row);\n      var match = line.match(/^(\\s*\\})/);\n      if (!match) return 0;\n      var column = match[1].length;\n      var openBracePos = doc.findMatchingBracket({\n        row: row,\n        column: column\n      });\n      if (!openBracePos || openBracePos.row == row) return 0;\n      var indent = this.$getIndent(doc.getLine(openBracePos.row));\n      doc.replace(new Range(row, 0, row, column - 1), indent);\n    };\n\n    this.$getIndent = function (line) {\n      return line.match(/^\\s*/)[0];\n    };\n  }).call(MatchingBraceOutdent.prototype);\n  exports.MatchingBraceOutdent = MatchingBraceOutdent;\n});\nace.define(\"ace/mode/livescript\", [\"require\", \"exports\", \"module\", \"ace/tokenizer\", \"ace/mode/matching_brace_outdent\", \"ace/mode/text\"], function (acequire, exports, module) {\n  var identifier, LiveScriptMode, keywordend, stringfill;\n  identifier = \"(?![\\\\d\\\\s])[$\\\\w\\\\xAA-\\\\uFFDC](?:(?!\\\\s)[$\\\\w\\\\xAA-\\\\uFFDC]|-[A-Za-z])*\";\n\n  exports.Mode = LiveScriptMode = function (superclass) {\n    var indenter,\n        prototype = extend$((import$(LiveScriptMode, superclass).displayName = 'LiveScriptMode', LiveScriptMode), superclass).prototype,\n        constructor = LiveScriptMode;\n\n    function LiveScriptMode() {\n      var that;\n      this.$tokenizer = new (acequire('../tokenizer').Tokenizer)(LiveScriptMode.Rules);\n\n      if (that = acequire('../mode/matching_brace_outdent')) {\n        this.$outdent = new that.MatchingBraceOutdent();\n      }\n\n      this.$id = \"ace/mode/livescript\";\n    }\n\n    indenter = RegExp('(?:[({[=:]|[-~]>|\\\\b(?:e(?:lse|xport)|d(?:o|efault)|t(?:ry|hen)|finally|import(?:\\\\s*all)?|const|var|let|new|catch(?:\\\\s*' + identifier + ')?))\\\\s*$');\n\n    prototype.getNextLineIndent = function (state, line, tab) {\n      var indent, tokens;\n      indent = this.$getIndent(line);\n      tokens = this.$tokenizer.getLineTokens(line, state).tokens;\n\n      if (!(tokens.length && tokens[tokens.length - 1].type === 'comment')) {\n        if (state === 'start' && indenter.test(line)) {\n          indent += tab;\n        }\n      }\n\n      return indent;\n    };\n\n    prototype.lineCommentStart = \"#\";\n    prototype.blockComment = {\n      start: \"###\",\n      end: \"###\"\n    };\n\n    prototype.checkOutdent = function (state, line, input) {\n      var ref$;\n      return (ref$ = this.$outdent) != null ? ref$.checkOutdent(line, input) : void 8;\n    };\n\n    prototype.autoOutdent = function (state, doc, row) {\n      var ref$;\n      return (ref$ = this.$outdent) != null ? ref$.autoOutdent(doc, row) : void 8;\n    };\n\n    return LiveScriptMode;\n  }(acequire('../mode/text').Mode);\n\n  keywordend = '(?![$\\\\w]|-[A-Za-z]|\\\\s*:(?![:=]))';\n  stringfill = {\n    defaultToken: 'string'\n  };\n  LiveScriptMode.Rules = {\n    start: [{\n      token: 'keyword',\n      regex: '(?:t(?:h(?:is|row|en)|ry|ypeof!?)|c(?:on(?:tinue|st)|a(?:se|tch)|lass)|i(?:n(?:stanceof)?|mp(?:ort(?:\\\\s+all)?|lements)|[fs])|d(?:e(?:fault|lete|bugger)|o)|f(?:or(?:\\\\s+own)?|inally|unction)|s(?:uper|witch)|e(?:lse|x(?:tends|port)|val)|a(?:nd|rguments)|n(?:ew|ot)|un(?:less|til)|w(?:hile|ith)|o[fr]|return|break|let|var|loop)' + keywordend\n    }, {\n      token: 'constant.language',\n      regex: '(?:true|false|yes|no|on|off|null|void|undefined)' + keywordend\n    }, {\n      token: 'invalid.illegal',\n      regex: '(?:p(?:ackage|r(?:ivate|otected)|ublic)|i(?:mplements|nterface)|enum|static|yield)' + keywordend\n    }, {\n      token: 'language.support.class',\n      regex: '(?:R(?:e(?:gExp|ferenceError)|angeError)|S(?:tring|yntaxError)|E(?:rror|valError)|Array|Boolean|Date|Function|Number|Object|TypeError|URIError)' + keywordend\n    }, {\n      token: 'language.support.function',\n      regex: '(?:is(?:NaN|Finite)|parse(?:Int|Float)|Math|JSON|(?:en|de)codeURI(?:Component)?)' + keywordend\n    }, {\n      token: 'variable.language',\n      regex: '(?:t(?:hat|il|o)|f(?:rom|allthrough)|it|by|e)' + keywordend\n    }, {\n      token: 'identifier',\n      regex: identifier + '\\\\s*:(?![:=])'\n    }, {\n      token: 'variable',\n      regex: identifier\n    }, {\n      token: 'keyword.operator',\n      regex: '(?:\\\\.{3}|\\\\s+\\\\?)'\n    }, {\n      token: 'keyword.variable',\n      regex: '(?:@+|::|\\\\.\\\\.)',\n      next: 'key'\n    }, {\n      token: 'keyword.operator',\n      regex: '\\\\.\\\\s*',\n      next: 'key'\n    }, {\n      token: 'string',\n      regex: '\\\\\\\\\\\\S[^\\\\s,;)}\\\\]]*'\n    }, {\n      token: 'string.doc',\n      regex: '\\'\\'\\'',\n      next: 'qdoc'\n    }, {\n      token: 'string.doc',\n      regex: '\"\"\"',\n      next: 'qqdoc'\n    }, {\n      token: 'string',\n      regex: '\\'',\n      next: 'qstring'\n    }, {\n      token: 'string',\n      regex: '\"',\n      next: 'qqstring'\n    }, {\n      token: 'string',\n      regex: '`',\n      next: 'js'\n    }, {\n      token: 'string',\n      regex: '<\\\\[',\n      next: 'words'\n    }, {\n      token: 'string.regex',\n      regex: '//',\n      next: 'heregex'\n    }, {\n      token: 'comment.doc',\n      regex: '/\\\\*',\n      next: 'comment'\n    }, {\n      token: 'comment',\n      regex: '#.*'\n    }, {\n      token: 'string.regex',\n      regex: '\\\\/(?:[^[\\\\/\\\\n\\\\\\\\]*(?:(?:\\\\\\\\.|\\\\[[^\\\\]\\\\n\\\\\\\\]*(?:\\\\\\\\.[^\\\\]\\\\n\\\\\\\\]*)*\\\\])[^[\\\\/\\\\n\\\\\\\\]*)*)\\\\/[gimy$]{0,4}',\n      next: 'key'\n    }, {\n      token: 'constant.numeric',\n      regex: '(?:0x[\\\\da-fA-F][\\\\da-fA-F_]*|(?:[2-9]|[12]\\\\d|3[0-6])r[\\\\da-zA-Z][\\\\da-zA-Z_]*|(?:\\\\d[\\\\d_]*(?:\\\\.\\\\d[\\\\d_]*)?|\\\\.\\\\d[\\\\d_]*)(?:e[+-]?\\\\d[\\\\d_]*)?[\\\\w$]*)'\n    }, {\n      token: 'lparen',\n      regex: '[({[]'\n    }, {\n      token: 'rparen',\n      regex: '[)}\\\\]]',\n      next: 'key'\n    }, {\n      token: 'keyword.operator',\n      regex: '[\\\\^!|&%+\\\\-]+'\n    }, {\n      token: 'text',\n      regex: '\\\\s+'\n    }],\n    heregex: [{\n      token: 'string.regex',\n      regex: '.*?//[gimy$?]{0,4}',\n      next: 'start'\n    }, {\n      token: 'string.regex',\n      regex: '\\\\s*#{'\n    }, {\n      token: 'comment.regex',\n      regex: '\\\\s+(?:#.*)?'\n    }, {\n      defaultToken: 'string.regex'\n    }],\n    key: [{\n      token: 'keyword.operator',\n      regex: '[.?@!]+'\n    }, {\n      token: 'identifier',\n      regex: identifier,\n      next: 'start'\n    }, {\n      token: 'text',\n      regex: '',\n      next: 'start'\n    }],\n    comment: [{\n      token: 'comment.doc',\n      regex: '.*?\\\\*/',\n      next: 'start'\n    }, {\n      defaultToken: 'comment.doc'\n    }],\n    qdoc: [{\n      token: 'string',\n      regex: \".*?'''\",\n      next: 'key'\n    }, stringfill],\n    qqdoc: [{\n      token: 'string',\n      regex: '.*?\"\"\"',\n      next: 'key'\n    }, stringfill],\n    qstring: [{\n      token: 'string',\n      regex: '[^\\\\\\\\\\']*(?:\\\\\\\\.[^\\\\\\\\\\']*)*\\'',\n      next: 'key'\n    }, stringfill],\n    qqstring: [{\n      token: 'string',\n      regex: '[^\\\\\\\\\"]*(?:\\\\\\\\.[^\\\\\\\\\"]*)*\"',\n      next: 'key'\n    }, stringfill],\n    js: [{\n      token: 'string',\n      regex: '[^\\\\\\\\`]*(?:\\\\\\\\.[^\\\\\\\\`]*)*`',\n      next: 'key'\n    }, stringfill],\n    words: [{\n      token: 'string',\n      regex: '.*?\\\\]>',\n      next: 'key'\n    }, stringfill]\n  };\n\n  function extend$(sub, sup) {\n    function fun() {}\n\n    fun.prototype = (sub.superclass = sup).prototype;\n    (sub.prototype = new fun()).constructor = sub;\n    if (typeof sup.extended == 'function') sup.extended(sub);\n    return sub;\n  }\n\n  function import$(obj, src) {\n    var own = {}.hasOwnProperty;\n\n    for (var key in src) {\n      if (own.call(src, key)) obj[key] = src[key];\n    }\n\n    return obj;\n  }\n});"],"sourceRoot":""}