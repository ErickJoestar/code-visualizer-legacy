{"version":3,"sources":["../node_modules/brace/mode/elixir.js"],"names":["ace","define","acequire","exports","module","oop","TextHighlightRules","ElixirHighlightRules","this","$rules","start","token","regex","push","next","include","defaultToken","comment","TODO","originalRegex","todo","normalizeRules","metaData","fileTypes","firstLineMatch","foldingStartMarker","foldingStopMarker","keyEquivalent","name","scopeName","inherits","BaseFoldMode","FoldMode","Range","getFoldWidgetRange","session","foldStyle","row","range","indentationBlock","re","line","getLine","startLevel","search","startColumn","length","maxRow","getLength","startRow","endRow","level","endColumn","getFoldWidget","indent","prev","prevIndent","nextIndent","foldWidgets","call","prototype","TextMode","Mode","HighlightRules","foldingRules","$behaviour","$defaultBehaviour","lineCommentStart","$id"],"mappings":"6HAAAA,IAAIC,OAAO,kCAAmC,CAAC,UAAW,UAAW,SAAU,cAAe,kCAAkC,SAAUC,EAAUC,EAASC,GAC3J,aAEA,IAAIC,EAAMH,EAAS,cACfI,EAAqBJ,EAAS,0BAA0BI,mBAExDC,EAAuB,WACzBC,KAAKC,OAAS,CACZC,MAAO,CAAC,CACNC,MAAO,CAAC,qBAAsB,gCAAiC,qBAAsB,kCACrFC,MAAO,gEACN,CACDD,MAAO,gCACPC,MAAO,sCACPC,KAAM,CAAC,CACLF,MAAO,gCACPC,MAAO,UACPE,KAAM,OACL,CACDC,QAAS,wBACR,CACDA,QAAS,iBACR,CACDC,aAAc,kCAEhBC,QAAS,kDACR,CACDN,MAAO,gCACPC,MAAO,iCACPC,KAAM,CAAC,CACLF,MAAO,gCACPC,MAAO,UACPE,KAAM,OACL,CACDE,aAAc,kCAEhBC,QAAS,kDACR,CACDN,MAAO,gCACPC,MAAO,sCACPC,KAAM,CAAC,CACLF,MAAO,gCACPC,MAAO,UACPE,KAAM,OACL,CACDC,QAAS,wBACR,CACDA,QAAS,iBACR,CACDC,aAAc,kCAEhBC,QAAS,kDACR,CACDN,MAAO,gCACPC,MAAO,iCACPC,KAAM,CAAC,CACLF,MAAO,gCACPC,MAAO,UACPE,KAAM,OACL,CACDE,aAAc,kCAEhBC,QAAS,kDACR,CACDN,MAAO,8BACPC,MAAO,6BACPK,QAAS,0CACR,CACDN,MAAO,+BACPC,MAAO,yBACPC,KAAM,CAAC,CACLF,MAAO,+BACPC,MAAO,IACPE,KAAM,OACL,CACDC,QAAS,wBACR,CACDA,QAAS,iBACR,CACDC,aAAc,iCAEhBC,QAAS,gDACR,CACDN,MAAO,yBACPC,MAAO,uSACPM,KAAM,2CACNC,cAAe,8SACd,CACDR,MAAO,0BACPC,MAAO,iDACPM,KAAM,2CACNC,cAAe,uDACfF,QAAS,mEACR,CACDN,MAAO,2BACPC,MAAO,oCACN,CACDD,MAAO,2BACPC,MAAO,+CACN,CACDD,MAAO,CAAC,yCAA0C,0CAClDC,MAAO,sBACN,CACDD,MAAO,CAAC,yCAA0C,mCAClDC,MAAO,aACN,CACDD,MAAO,iCACPC,MAAO,mBACN,CACDD,MAAO,0BACPC,MAAO,iJACPM,KAAM,2CACNC,cAAe,4HACd,CACDR,MAAO,yCACPC,MAAO,KACPC,KAAM,CAAC,CACLF,MAAO,yCACPC,MAAO,IACPE,KAAM,OACL,CACDC,QAAS,wBACR,CACDA,QAAS,iBACR,CACDC,aAAc,gDAEf,CACDL,MAAO,yCACPC,MAAO,KACPC,KAAM,CAAC,CACLF,MAAO,yCACPC,MAAO,IACPE,KAAM,OACL,CACDC,QAAS,wBACR,CACDA,QAAS,iBACR,CACDC,aAAc,gDAEf,CACDL,MAAO,6CACPC,MAAO,UACPM,KAAM,2CACNC,cAAe,UACfN,KAAM,CAAC,CACLF,MAAO,2CACPC,MAAO,WACPE,KAAM,OACL,CACDC,QAAS,wBACR,CACDA,QAAS,iBACR,CACDC,aAAc,2DAEhBC,QAAS,0BACR,CACDN,MAAO,6CACPC,MAAO,IACPC,KAAM,CAAC,CACLF,MAAO,2CACPC,MAAO,IACPE,KAAM,OACL,CACDC,QAAS,wBACR,CACDA,QAAS,iBACR,CACDC,aAAc,mDAEhBC,QAAS,mDACR,CACDN,MAAO,6CACPC,MAAO,UACPM,KAAM,2CACNC,cAAe,UACfN,KAAM,CAAC,CACLF,MAAO,2CACPC,MAAO,WACPE,KAAM,OACL,CACDC,QAAS,wBACR,CACDA,QAAS,iBACR,CACDC,aAAc,wCAEhBC,QAAS,0BACR,CACDN,MAAO,6CACPC,MAAO,IACPC,KAAM,CAAC,CACLF,MAAO,2CACPC,MAAO,IACPE,KAAM,OACL,CACDC,QAAS,wBACR,CACDA,QAAS,iBACR,CACDC,aAAc,gCAEhBC,QAAS,mDACR,CACDN,MAAO,6CACPC,MAAO,gBACPM,KAAM,2CACNC,cAAe,gBACfN,KAAM,CAAC,CACLF,MAAO,2CACPC,MAAO,WACPE,KAAM,OACL,CACDC,QAAS,wBACR,CACDA,QAAS,iBACR,CACDC,aAAc,wCAEhBC,QAAS,iCACR,CACDN,MAAO,6CACPC,MAAO,YACPC,KAAM,CAAC,CACLF,MAAO,2CACPC,MAAO,YACPE,KAAM,OACL,CACDC,QAAS,wBACR,CACD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","file":"static/js/37.499cc49a.chunk.js","sourcesContent":["ace.define(\"ace/mode/elixir_highlight_rules\", [\"require\", \"exports\", \"module\", \"ace/lib/oop\", \"ace/mode/text_highlight_rules\"], function (acequire, exports, module) {\n  \"use strict\";\n\n  var oop = acequire(\"../lib/oop\");\n  var TextHighlightRules = acequire(\"./text_highlight_rules\").TextHighlightRules;\n\n  var ElixirHighlightRules = function ElixirHighlightRules() {\n    this.$rules = {\n      start: [{\n        token: ['meta.module.elixir', 'keyword.control.module.elixir', 'meta.module.elixir', 'entity.name.type.module.elixir'],\n        regex: '^(\\\\s*)(defmodule)(\\\\s+)((?:[A-Z]\\\\w*\\\\s*\\\\.\\\\s*)*[A-Z]\\\\w*)'\n      }, {\n        token: 'comment.documentation.heredoc',\n        regex: '@(?:module|type)?doc (?:~[a-z])?\"\"\"',\n        push: [{\n          token: 'comment.documentation.heredoc',\n          regex: '\\\\s*\"\"\"',\n          next: 'pop'\n        }, {\n          include: '#interpolated_elixir'\n        }, {\n          include: '#escaped_char'\n        }, {\n          defaultToken: 'comment.documentation.heredoc'\n        }],\n        comment: '@doc with heredocs is treated as documentation'\n      }, {\n        token: 'comment.documentation.heredoc',\n        regex: '@(?:module|type)?doc ~[A-Z]\"\"\"',\n        push: [{\n          token: 'comment.documentation.heredoc',\n          regex: '\\\\s*\"\"\"',\n          next: 'pop'\n        }, {\n          defaultToken: 'comment.documentation.heredoc'\n        }],\n        comment: '@doc with heredocs is treated as documentation'\n      }, {\n        token: 'comment.documentation.heredoc',\n        regex: '@(?:module|type)?doc (?:~[a-z])?\\'\\'\\'',\n        push: [{\n          token: 'comment.documentation.heredoc',\n          regex: '\\\\s*\\'\\'\\'',\n          next: 'pop'\n        }, {\n          include: '#interpolated_elixir'\n        }, {\n          include: '#escaped_char'\n        }, {\n          defaultToken: 'comment.documentation.heredoc'\n        }],\n        comment: '@doc with heredocs is treated as documentation'\n      }, {\n        token: 'comment.documentation.heredoc',\n        regex: '@(?:module|type)?doc ~[A-Z]\\'\\'\\'',\n        push: [{\n          token: 'comment.documentation.heredoc',\n          regex: '\\\\s*\\'\\'\\'',\n          next: 'pop'\n        }, {\n          defaultToken: 'comment.documentation.heredoc'\n        }],\n        comment: '@doc with heredocs is treated as documentation'\n      }, {\n        token: 'comment.documentation.false',\n        regex: '@(?:module|type)?doc false',\n        comment: '@doc false is treated as documentation'\n      }, {\n        token: 'comment.documentation.string',\n        regex: '@(?:module|type)?doc \"',\n        push: [{\n          token: 'comment.documentation.string',\n          regex: '\"',\n          next: 'pop'\n        }, {\n          include: '#interpolated_elixir'\n        }, {\n          include: '#escaped_char'\n        }, {\n          defaultToken: 'comment.documentation.string'\n        }],\n        comment: '@doc with string is treated as documentation'\n      }, {\n        token: 'keyword.control.elixir',\n        regex: '\\\\b(?:do|end|case|bc|lc|for|if|cond|unless|try|receive|fn|defmodule|defp?|defprotocol|defimpl|defrecord|defstruct|defmacrop?|defdelegate|defcallback|defmacrocallback|defexception|defoverridable|exit|after|rescue|catch|else|raise|throw|import|acequire|alias|use|quote|unquote|super)\\\\b(?![?!])',\n        TODO: 'FIXME: regexp doesn\\'t have js equivalent',\n        originalRegex: '(?<!\\\\.)\\\\b(do|end|case|bc|lc|for|if|cond|unless|try|receive|fn|defmodule|defp?|defprotocol|defimpl|defrecord|defstruct|defmacrop?|defdelegate|defcallback|defmacrocallback|defexception|defoverridable|exit|after|rescue|catch|else|raise|throw|import|acequire|alias|use|quote|unquote|super)\\\\b(?![?!])'\n      }, {\n        token: 'keyword.operator.elixir',\n        regex: '\\\\b(?:and|not|or|when|xor|in|inlist|inbits)\\\\b',\n        TODO: 'FIXME: regexp doesn\\'t have js equivalent',\n        originalRegex: '(?<!\\\\.)\\\\b(and|not|or|when|xor|in|inlist|inbits)\\\\b',\n        comment: ' as above, just doesn\\'t need a \\'end\\' and does a logic operation'\n      }, {\n        token: 'constant.language.elixir',\n        regex: '\\\\b(?:nil|true|false)\\\\b(?![?!])'\n      }, {\n        token: 'variable.language.elixir',\n        regex: '\\\\b__(?:CALLER|ENV|MODULE|DIR)__\\\\b(?![?!])'\n      }, {\n        token: ['punctuation.definition.variable.elixir', 'variable.other.readwrite.module.elixir'],\n        regex: '(@)([a-zA-Z_]\\\\w*)'\n      }, {\n        token: ['punctuation.definition.variable.elixir', 'variable.other.anonymous.elixir'],\n        regex: '(&)(\\\\d*)'\n      }, {\n        token: 'variable.other.constant.elixir',\n        regex: '\\\\b[A-Z]\\\\w*\\\\b'\n      }, {\n        token: 'constant.numeric.elixir',\n        regex: '\\\\b(?:0x[\\\\da-fA-F](?:_?[\\\\da-fA-F])*|\\\\d(?:_?\\\\d)*(?:\\\\.(?![^[:space:][:digit:]])(?:_?\\\\d)*)?(?:[eE][-+]?\\\\d(?:_?\\\\d)*)?|0b[01]+|0o[0-7]+)\\\\b',\n        TODO: 'FIXME: regexp doesn\\'t have js equivalent',\n        originalRegex: '\\\\b(0x\\\\h(?>_?\\\\h)*|\\\\d(?>_?\\\\d)*(\\\\.(?![^[:space:][:digit:]])(?>_?\\\\d)*)?([eE][-+]?\\\\d(?>_?\\\\d)*)?|0b[01]+|0o[0-7]+)\\\\b'\n      }, {\n        token: 'punctuation.definition.constant.elixir',\n        regex: ':\\'',\n        push: [{\n          token: 'punctuation.definition.constant.elixir',\n          regex: '\\'',\n          next: 'pop'\n        }, {\n          include: '#interpolated_elixir'\n        }, {\n          include: '#escaped_char'\n        }, {\n          defaultToken: 'constant.other.symbol.single-quoted.elixir'\n        }]\n      }, {\n        token: 'punctuation.definition.constant.elixir',\n        regex: ':\"',\n        push: [{\n          token: 'punctuation.definition.constant.elixir',\n          regex: '\"',\n          next: 'pop'\n        }, {\n          include: '#interpolated_elixir'\n        }, {\n          include: '#escaped_char'\n        }, {\n          defaultToken: 'constant.other.symbol.double-quoted.elixir'\n        }]\n      }, {\n        token: 'punctuation.definition.string.begin.elixir',\n        regex: '(?:\\'\\'\\')',\n        TODO: 'FIXME: regexp doesn\\'t have js equivalent',\n        originalRegex: '(?>\\'\\'\\')',\n        push: [{\n          token: 'punctuation.definition.string.end.elixir',\n          regex: '^\\\\s*\\'\\'\\'',\n          next: 'pop'\n        }, {\n          include: '#interpolated_elixir'\n        }, {\n          include: '#escaped_char'\n        }, {\n          defaultToken: 'support.function.variable.quoted.single.heredoc.elixir'\n        }],\n        comment: 'Single-quoted heredocs'\n      }, {\n        token: 'punctuation.definition.string.begin.elixir',\n        regex: '\\'',\n        push: [{\n          token: 'punctuation.definition.string.end.elixir',\n          regex: '\\'',\n          next: 'pop'\n        }, {\n          include: '#interpolated_elixir'\n        }, {\n          include: '#escaped_char'\n        }, {\n          defaultToken: 'support.function.variable.quoted.single.elixir'\n        }],\n        comment: 'single quoted string (allows for interpolation)'\n      }, {\n        token: 'punctuation.definition.string.begin.elixir',\n        regex: '(?:\"\"\")',\n        TODO: 'FIXME: regexp doesn\\'t have js equivalent',\n        originalRegex: '(?>\"\"\")',\n        push: [{\n          token: 'punctuation.definition.string.end.elixir',\n          regex: '^\\\\s*\"\"\"',\n          next: 'pop'\n        }, {\n          include: '#interpolated_elixir'\n        }, {\n          include: '#escaped_char'\n        }, {\n          defaultToken: 'string.quoted.double.heredoc.elixir'\n        }],\n        comment: 'Double-quoted heredocs'\n      }, {\n        token: 'punctuation.definition.string.begin.elixir',\n        regex: '\"',\n        push: [{\n          token: 'punctuation.definition.string.end.elixir',\n          regex: '\"',\n          next: 'pop'\n        }, {\n          include: '#interpolated_elixir'\n        }, {\n          include: '#escaped_char'\n        }, {\n          defaultToken: 'string.quoted.double.elixir'\n        }],\n        comment: 'double quoted string (allows for interpolation)'\n      }, {\n        token: 'punctuation.definition.string.begin.elixir',\n        regex: '~[a-z](?:\"\"\")',\n        TODO: 'FIXME: regexp doesn\\'t have js equivalent',\n        originalRegex: '~[a-z](?>\"\"\")',\n        push: [{\n          token: 'punctuation.definition.string.end.elixir',\n          regex: '^\\\\s*\"\"\"',\n          next: 'pop'\n        }, {\n          include: '#interpolated_elixir'\n        }, {\n          include: '#escaped_char'\n        }, {\n          defaultToken: 'string.quoted.double.heredoc.elixir'\n        }],\n        comment: 'Double-quoted heredocs sigils'\n      }, {\n        token: 'punctuation.definition.string.begin.elixir',\n        regex: '~[a-z]\\\\{',\n        push: [{\n          token: 'punctuation.definition.string.end.elixir',\n          regex: '\\\\}[a-z]*',\n          next: 'pop'\n        }, {\n          include: '#interpolated_elixir'\n        }, {\n          include: '#escaped_char'\n        }, {\n          defaultToken: 'string.interpolated.elixir'\n        }],\n        comment: 'sigil (allow for interpolation)'\n      }, {\n        token: 'punctuation.definition.string.begin.elixir',\n        regex: '~[a-z]\\\\[',\n        push: [{\n          token: 'punctuation.definition.string.end.elixir',\n          regex: '\\\\][a-z]*',\n          next: 'pop'\n        }, {\n          include: '#interpolated_elixir'\n        }, {\n          include: '#escaped_char'\n        }, {\n          defaultToken: 'string.interpolated.elixir'\n        }],\n        comment: 'sigil (allow for interpolation)'\n      }, {\n        token: 'punctuation.definition.string.begin.elixir',\n        regex: '~[a-z]\\\\<',\n        push: [{\n          token: 'punctuation.definition.string.end.elixir',\n          regex: '\\\\>[a-z]*',\n          next: 'pop'\n        }, {\n          include: '#interpolated_elixir'\n        }, {\n          include: '#escaped_char'\n        }, {\n          defaultToken: 'string.interpolated.elixir'\n        }],\n        comment: 'sigil (allow for interpolation)'\n      }, {\n        token: 'punctuation.definition.string.begin.elixir',\n        regex: '~[a-z]\\\\(',\n        push: [{\n          token: 'punctuation.definition.string.end.elixir',\n          regex: '\\\\)[a-z]*',\n          next: 'pop'\n        }, {\n          include: '#interpolated_elixir'\n        }, {\n          include: '#escaped_char'\n        }, {\n          defaultToken: 'string.interpolated.elixir'\n        }],\n        comment: 'sigil (allow for interpolation)'\n      }, {\n        token: 'punctuation.definition.string.begin.elixir',\n        regex: '~[a-z][^\\\\w]',\n        push: [{\n          token: 'punctuation.definition.string.end.elixir',\n          regex: '[^\\\\w][a-z]*',\n          next: 'pop'\n        }, {\n          include: '#interpolated_elixir'\n        }, {\n          include: '#escaped_char'\n        }, {\n          include: '#escaped_char'\n        }, {\n          defaultToken: 'string.interpolated.elixir'\n        }],\n        comment: 'sigil (allow for interpolation)'\n      }, {\n        token: 'punctuation.definition.string.begin.elixir',\n        regex: '~[A-Z](?:\"\"\")',\n        TODO: 'FIXME: regexp doesn\\'t have js equivalent',\n        originalRegex: '~[A-Z](?>\"\"\")',\n        push: [{\n          token: 'punctuation.definition.string.end.elixir',\n          regex: '^\\\\s*\"\"\"',\n          next: 'pop'\n        }, {\n          defaultToken: 'string.quoted.other.literal.upper.elixir'\n        }],\n        comment: 'Double-quoted heredocs sigils'\n      }, {\n        token: 'punctuation.definition.string.begin.elixir',\n        regex: '~[A-Z]\\\\{',\n        push: [{\n          token: 'punctuation.definition.string.end.elixir',\n          regex: '\\\\}[a-z]*',\n          next: 'pop'\n        }, {\n          defaultToken: 'string.quoted.other.literal.upper.elixir'\n        }],\n        comment: 'sigil (without interpolation)'\n      }, {\n        token: 'punctuation.definition.string.begin.elixir',\n        regex: '~[A-Z]\\\\[',\n        push: [{\n          token: 'punctuation.definition.string.end.elixir',\n          regex: '\\\\][a-z]*',\n          next: 'pop'\n        }, {\n          defaultToken: 'string.quoted.other.literal.upper.elixir'\n        }],\n        comment: 'sigil (without interpolation)'\n      }, {\n        token: 'punctuation.definition.string.begin.elixir',\n        regex: '~[A-Z]\\\\<',\n        push: [{\n          token: 'punctuation.definition.string.end.elixir',\n          regex: '\\\\>[a-z]*',\n          next: 'pop'\n        }, {\n          defaultToken: 'string.quoted.other.literal.upper.elixir'\n        }],\n        comment: 'sigil (without interpolation)'\n      }, {\n        token: 'punctuation.definition.string.begin.elixir',\n        regex: '~[A-Z]\\\\(',\n        push: [{\n          token: 'punctuation.definition.string.end.elixir',\n          regex: '\\\\)[a-z]*',\n          next: 'pop'\n        }, {\n          defaultToken: 'string.quoted.other.literal.upper.elixir'\n        }],\n        comment: 'sigil (without interpolation)'\n      }, {\n        token: 'punctuation.definition.string.begin.elixir',\n        regex: '~[A-Z][^\\\\w]',\n        push: [{\n          token: 'punctuation.definition.string.end.elixir',\n          regex: '[^\\\\w][a-z]*',\n          next: 'pop'\n        }, {\n          defaultToken: 'string.quoted.other.literal.upper.elixir'\n        }],\n        comment: 'sigil (without interpolation)'\n      }, {\n        token: ['punctuation.definition.constant.elixir', 'constant.other.symbol.elixir'],\n        regex: '(:)([a-zA-Z_][\\\\w@]*(?:[?!]|=(?![>=]))?|\\\\<\\\\>|===?|!==?|<<>>|<<<|>>>|~~~|::|<\\\\-|\\\\|>|=>|~|~=|=|/|\\\\\\\\\\\\\\\\|\\\\*\\\\*?|\\\\.\\\\.?\\\\.?|>=?|<=?|&&?&?|\\\\+\\\\+?|\\\\-\\\\-?|\\\\|\\\\|?\\\\|?|\\\\!|@|\\\\%?\\\\{\\\\}|%|\\\\[\\\\]|\\\\^(?:\\\\^\\\\^)?)',\n        TODO: 'FIXME: regexp doesn\\'t have js equivalent',\n        originalRegex: '(?<!:)(:)(?>[a-zA-Z_][\\\\w@]*(?>[?!]|=(?![>=]))?|\\\\<\\\\>|===?|!==?|<<>>|<<<|>>>|~~~|::|<\\\\-|\\\\|>|=>|~|~=|=|/|\\\\\\\\\\\\\\\\|\\\\*\\\\*?|\\\\.\\\\.?\\\\.?|>=?|<=?|&&?&?|\\\\+\\\\+?|\\\\-\\\\-?|\\\\|\\\\|?\\\\|?|\\\\!|@|\\\\%?\\\\{\\\\}|%|\\\\[\\\\]|\\\\^(\\\\^\\\\^)?)',\n        comment: 'symbols'\n      }, {\n        token: 'punctuation.definition.constant.elixir',\n        regex: '(?:[a-zA-Z_][\\\\w@]*(?:[?!])?):(?!:)',\n        TODO: 'FIXME: regexp doesn\\'t have js equivalent',\n        originalRegex: '(?>[a-zA-Z_][\\\\w@]*(?>[?!])?)(:)(?!:)',\n        comment: 'symbols'\n      }, {\n        token: ['punctuation.definition.comment.elixir', 'comment.line.number-sign.elixir'],\n        regex: '(#)(.*)'\n      }, {\n        token: 'constant.numeric.elixir',\n        regex: '\\\\?(?:\\\\\\\\(?:x[\\\\da-fA-F]{1,2}(?![\\\\da-fA-F])\\\\b|[^xMC])|[^\\\\s\\\\\\\\])',\n        TODO: 'FIXME: regexp doesn\\'t have js equivalent',\n        originalRegex: '(?<!\\\\w)\\\\?(\\\\\\\\(x\\\\h{1,2}(?!\\\\h)\\\\b|[^xMC])|[^\\\\s\\\\\\\\])',\n        comment: '\\n\\t\\t\\tmatches questionmark-letters.\\n\\n\\t\\t\\texamples (1st alternation = hex):\\n\\t\\t\\t?\\\\x1     ?\\\\x61\\n\\n\\t\\t\\texamples (2rd alternation = escaped):\\n\\t\\t\\t?\\\\n      ?\\\\b\\n\\n\\t\\t\\texamples (3rd alternation = normal):\\n\\t\\t\\t?a       ?A       ?0 \\n\\t\\t\\t?*       ?\"       ?( \\n\\t\\t\\t?.       ?#\\n\\t\\t\\t\\n\\t\\t\\tthe negative lookbehind prevents against matching\\n\\t\\t\\tp(42.tainted?)\\n\\t\\t\\t'\n      }, {\n        token: 'keyword.operator.assignment.augmented.elixir',\n        regex: '\\\\+=|\\\\-=|\\\\|\\\\|=|~=|&&='\n      }, {\n        token: 'keyword.operator.comparison.elixir',\n        regex: '===?|!==?|<=?|>=?'\n      }, {\n        token: 'keyword.operator.bitwise.elixir',\n        regex: '\\\\|{3}|&{3}|\\\\^{3}|<{3}|>{3}|~{3}'\n      }, {\n        token: 'keyword.operator.logical.elixir',\n        regex: '!+|\\\\bnot\\\\b|&&|\\\\band\\\\b|\\\\|\\\\||\\\\bor\\\\b|\\\\bxor\\\\b',\n        originalRegex: '(?<=[ \\\\t])!+|\\\\bnot\\\\b|&&|\\\\band\\\\b|\\\\|\\\\||\\\\bor\\\\b|\\\\bxor\\\\b'\n      }, {\n        token: 'keyword.operator.arithmetic.elixir',\n        regex: '\\\\*|\\\\+|\\\\-|/'\n      }, {\n        token: 'keyword.operator.other.elixir',\n        regex: '\\\\||\\\\+\\\\+|\\\\-\\\\-|\\\\*\\\\*|\\\\\\\\\\\\\\\\|\\\\<\\\\-|\\\\<\\\\>|\\\\<\\\\<|\\\\>\\\\>|\\\\:\\\\:|\\\\.\\\\.|\\\\|>|~|=>'\n      }, {\n        token: 'keyword.operator.assignment.elixir',\n        regex: '='\n      }, {\n        token: 'punctuation.separator.other.elixir',\n        regex: ':'\n      }, {\n        token: 'punctuation.separator.statement.elixir',\n        regex: '\\\\;'\n      }, {\n        token: 'punctuation.separator.object.elixir',\n        regex: ','\n      }, {\n        token: 'punctuation.separator.method.elixir',\n        regex: '\\\\.'\n      }, {\n        token: 'punctuation.section.scope.elixir',\n        regex: '\\\\{|\\\\}'\n      }, {\n        token: 'punctuation.section.array.elixir',\n        regex: '\\\\[|\\\\]'\n      }, {\n        token: 'punctuation.section.function.elixir',\n        regex: '\\\\(|\\\\)'\n      }],\n      '#escaped_char': [{\n        token: 'constant.character.escape.elixir',\n        regex: '\\\\\\\\(?:x[\\\\da-fA-F]{1,2}|.)'\n      }],\n      '#interpolated_elixir': [{\n        token: ['source.elixir.embedded.source', 'source.elixir.embedded.source.empty'],\n        regex: '(#\\\\{)(\\\\})'\n      }, {\n        todo: {\n          token: 'punctuation.section.embedded.elixir',\n          regex: '#\\\\{',\n          push: [{\n            token: 'punctuation.section.embedded.elixir',\n            regex: '\\\\}',\n            next: 'pop'\n          }, {\n            include: '#nest_curly_and_self'\n          }, {\n            include: '$self'\n          }, {\n            defaultToken: 'source.elixir.embedded.source'\n          }]\n        }\n      }],\n      '#nest_curly_and_self': [{\n        token: 'punctuation.section.scope.elixir',\n        regex: '\\\\{',\n        push: [{\n          token: 'punctuation.section.scope.elixir',\n          regex: '\\\\}',\n          next: 'pop'\n        }, {\n          include: '#nest_curly_and_self'\n        }]\n      }, {\n        include: '$self'\n      }],\n      '#regex_sub': [{\n        include: '#interpolated_elixir'\n      }, {\n        include: '#escaped_char'\n      }, {\n        token: ['punctuation.definition.arbitrary-repitition.elixir', 'string.regexp.arbitrary-repitition.elixir', 'string.regexp.arbitrary-repitition.elixir', 'punctuation.definition.arbitrary-repitition.elixir'],\n        regex: '(\\\\{)(\\\\d+)((?:,\\\\d+)?)(\\\\})'\n      }, {\n        token: 'punctuation.definition.character-class.elixir',\n        regex: '\\\\[(?:\\\\^?\\\\])?',\n        push: [{\n          token: 'punctuation.definition.character-class.elixir',\n          regex: '\\\\]',\n          next: 'pop'\n        }, {\n          include: '#escaped_char'\n        }, {\n          defaultToken: 'string.regexp.character-class.elixir'\n        }]\n      }, {\n        token: 'punctuation.definition.group.elixir',\n        regex: '\\\\(',\n        push: [{\n          token: 'punctuation.definition.group.elixir',\n          regex: '\\\\)',\n          next: 'pop'\n        }, {\n          include: '#regex_sub'\n        }, {\n          defaultToken: 'string.regexp.group.elixir'\n        }]\n      }, {\n        token: ['punctuation.definition.comment.elixir', 'comment.line.number-sign.elixir'],\n        regex: '(?:^|\\\\s)(#)(\\\\s[[a-zA-Z0-9,. \\\\t?!-][^\\\\x00-\\\\x7F]]*$)',\n        originalRegex: '(?<=^|\\\\s)(#)\\\\s[[a-zA-Z0-9,. \\\\t?!-][^\\\\x{00}-\\\\x{7F}]]*$',\n        comment: 'We are restrictive in what we allow to go after the comment character to avoid false positives, since the availability of comments depend on regexp flags.'\n      }]\n    };\n    this.normalizeRules();\n  };\n\n  ElixirHighlightRules.metaData = {\n    comment: 'Textmate bundle for Elixir Programming Language.',\n    fileTypes: ['ex', 'exs'],\n    firstLineMatch: '^#!/.*\\\\belixir',\n    foldingStartMarker: '(after|else|catch|rescue|\\\\-\\\\>|\\\\{|\\\\[|do)\\\\s*$',\n    foldingStopMarker: '^\\\\s*((\\\\}|\\\\]|after|else|catch|rescue)\\\\s*$|end\\\\b)',\n    keyEquivalent: '^~E',\n    name: 'Elixir',\n    scopeName: 'source.elixir'\n  };\n  oop.inherits(ElixirHighlightRules, TextHighlightRules);\n  exports.ElixirHighlightRules = ElixirHighlightRules;\n});\nace.define(\"ace/mode/folding/coffee\", [\"require\", \"exports\", \"module\", \"ace/lib/oop\", \"ace/mode/folding/fold_mode\", \"ace/range\"], function (acequire, exports, module) {\n  \"use strict\";\n\n  var oop = acequire(\"../../lib/oop\");\n  var BaseFoldMode = acequire(\"./fold_mode\").FoldMode;\n  var Range = acequire(\"../../range\").Range;\n\n  var FoldMode = exports.FoldMode = function () {};\n\n  oop.inherits(FoldMode, BaseFoldMode);\n  (function () {\n    this.getFoldWidgetRange = function (session, foldStyle, row) {\n      var range = this.indentationBlock(session, row);\n      if (range) return range;\n      var re = /\\S/;\n      var line = session.getLine(row);\n      var startLevel = line.search(re);\n      if (startLevel == -1 || line[startLevel] != \"#\") return;\n      var startColumn = line.length;\n      var maxRow = session.getLength();\n      var startRow = row;\n      var endRow = row;\n\n      while (++row < maxRow) {\n        line = session.getLine(row);\n        var level = line.search(re);\n        if (level == -1) continue;\n        if (line[level] != \"#\") break;\n        endRow = row;\n      }\n\n      if (endRow > startRow) {\n        var endColumn = session.getLine(endRow).length;\n        return new Range(startRow, startColumn, endRow, endColumn);\n      }\n    };\n\n    this.getFoldWidget = function (session, foldStyle, row) {\n      var line = session.getLine(row);\n      var indent = line.search(/\\S/);\n      var next = session.getLine(row + 1);\n      var prev = session.getLine(row - 1);\n      var prevIndent = prev.search(/\\S/);\n      var nextIndent = next.search(/\\S/);\n\n      if (indent == -1) {\n        session.foldWidgets[row - 1] = prevIndent != -1 && prevIndent < nextIndent ? \"start\" : \"\";\n        return \"\";\n      }\n\n      if (prevIndent == -1) {\n        if (indent == nextIndent && line[indent] == \"#\" && next[indent] == \"#\") {\n          session.foldWidgets[row - 1] = \"\";\n          session.foldWidgets[row + 1] = \"\";\n          return \"start\";\n        }\n      } else if (prevIndent == indent && line[indent] == \"#\" && prev[indent] == \"#\") {\n        if (session.getLine(row - 2).search(/\\S/) == -1) {\n          session.foldWidgets[row - 1] = \"start\";\n          session.foldWidgets[row + 1] = \"\";\n          return \"\";\n        }\n      }\n\n      if (prevIndent != -1 && prevIndent < indent) session.foldWidgets[row - 1] = \"start\";else session.foldWidgets[row - 1] = \"\";\n      if (indent < nextIndent) return \"start\";else return \"\";\n    };\n  }).call(FoldMode.prototype);\n});\nace.define(\"ace/mode/elixir\", [\"require\", \"exports\", \"module\", \"ace/lib/oop\", \"ace/mode/text\", \"ace/mode/elixir_highlight_rules\", \"ace/mode/folding/coffee\"], function (acequire, exports, module) {\n  \"use strict\";\n\n  var oop = acequire(\"../lib/oop\");\n  var TextMode = acequire(\"./text\").Mode;\n  var ElixirHighlightRules = acequire(\"./elixir_highlight_rules\").ElixirHighlightRules;\n  var FoldMode = acequire(\"./folding/coffee\").FoldMode;\n\n  var Mode = function Mode() {\n    this.HighlightRules = ElixirHighlightRules;\n    this.foldingRules = new FoldMode();\n    this.$behaviour = this.$defaultBehaviour;\n  };\n\n  oop.inherits(Mode, TextMode);\n  (function () {\n    this.lineCommentStart = \"#\";\n    this.$id = \"ace/mode/elixir\";\n  }).call(Mode.prototype);\n  exports.Mode = Mode;\n});"],"sourceRoot":""}