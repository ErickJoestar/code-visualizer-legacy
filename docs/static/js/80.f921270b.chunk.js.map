{"version":3,"sources":["../node_modules/brace/mode/lua.js"],"names":["ace","define","acequire","exports","module","oop","TextHighlightRules","LuaHighlightRules","keywordMapper","this","createKeywordMapper","$rules","stateName","onMatch","value","currentState","stack","unshift","next","length","regex","shift","defaultToken","token","integer","normalizeRules","inherits","BaseFoldMode","FoldMode","Range","TokenIterator","foldingStartMarker","foldingStopMarker","getFoldWidget","session","foldStyle","row","line","getLine","isStart","test","isEnd","match","getTokenAt","index","type","bgTokenizer","getState","getFoldWidgetRange","doc","exec","luaBlock","getCommentFoldRange","openingBracketBlock","closingBracketBlock","column","stream","indentKeywords","getCurrentToken","val","dir","startColumn","getCurrentTokenColumn","startRow","step","stepBackward","stepForward","level","getCurrentTokenRow","call","prototype","TextMode","Mode","LuaFoldMode","WorkerClient","HighlightRules","foldingRules","$behaviour","$defaultBehaviour","lineCommentStart","blockComment","start","end","outdentKeywords","getNetIndentLevel","tokens","i","getNextLineIndent","state","tab","indent","$getIndent","getTokenizer","getLineTokens","substr","checkOutdent","input","trim","indexOf","autoOutdent","prevLine","prevIndent","prevTokens","expectedIndent","getTabString","outdentRows","createWorker","worker","attachToDocument","getDocument","on","e","setAnnotations","data","clearAnnotations","$id"],"mappings":"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","file":"static/js/80.f921270b.chunk.js","sourcesContent":["ace.define(\"ace/mode/lua_highlight_rules\", [\"require\", \"exports\", \"module\", \"ace/lib/oop\", \"ace/mode/text_highlight_rules\"], function (acequire, exports, module) {\n  \"use strict\";\n\n  var oop = acequire(\"../lib/oop\");\n  var TextHighlightRules = acequire(\"./text_highlight_rules\").TextHighlightRules;\n\n  var LuaHighlightRules = function LuaHighlightRules() {\n    var keywords = \"break|do|else|elseif|end|for|function|if|in|local|repeat|\" + \"return|then|until|while|or|and|not\";\n    var builtinConstants = \"true|false|nil|_G|_VERSION\";\n    var functions = \"string|xpcall|package|tostring|print|os|unpack|acequire|\" + \"getfenv|setmetatable|next|assert|tonumber|io|rawequal|\" + \"collectgarbage|getmetatable|module|rawset|math|debug|\" + \"pcall|table|newproxy|type|coroutine|_G|select|gcinfo|\" + \"pairs|rawget|loadstring|ipairs|_VERSION|dofile|setfenv|\" + \"load|error|loadfile|\" + \"sub|upper|len|gfind|rep|find|match|char|dump|gmatch|\" + \"reverse|byte|format|gsub|lower|preload|loadlib|loaded|\" + \"loaders|cpath|config|path|seeall|exit|setlocale|date|\" + \"getenv|difftime|remove|time|clock|tmpname|rename|execute|\" + \"lines|write|close|flush|open|output|type|read|stderr|\" + \"stdin|input|stdout|popen|tmpfile|log|max|acos|huge|\" + \"ldexp|pi|cos|tanh|pow|deg|tan|cosh|sinh|random|randomseed|\" + \"frexp|ceil|floor|rad|abs|sqrt|modf|asin|min|mod|fmod|log10|\" + \"atan2|exp|sin|atan|getupvalue|debug|sethook|getmetatable|\" + \"gethook|setmetatable|setlocal|traceback|setfenv|getinfo|\" + \"setupvalue|getlocal|getregistry|getfenv|setn|insert|getn|\" + \"foreachi|maxn|foreach|concat|sort|remove|resume|yield|\" + \"status|wrap|create|running|\" + \"__add|__sub|__mod|__unm|__concat|__lt|__index|__call|__gc|__metatable|\" + \"__mul|__div|__pow|__len|__eq|__le|__newindex|__tostring|__mode|__tonumber\";\n    var stdLibaries = \"string|package|os|io|math|debug|table|coroutine\";\n    var deprecatedIn5152 = \"setn|foreach|foreachi|gcinfo|log10|maxn\";\n    var keywordMapper = this.createKeywordMapper({\n      \"keyword\": keywords,\n      \"support.function\": functions,\n      \"keyword.deprecated\": deprecatedIn5152,\n      \"constant.library\": stdLibaries,\n      \"constant.language\": builtinConstants,\n      \"variable.language\": \"self\"\n    }, \"identifier\");\n    var decimalInteger = \"(?:(?:[1-9]\\\\d*)|(?:0))\";\n    var hexInteger = \"(?:0[xX][\\\\dA-Fa-f]+)\";\n    var integer = \"(?:\" + decimalInteger + \"|\" + hexInteger + \")\";\n    var fraction = \"(?:\\\\.\\\\d+)\";\n    var intPart = \"(?:\\\\d+)\";\n    var pointFloat = \"(?:(?:\" + intPart + \"?\" + fraction + \")|(?:\" + intPart + \"\\\\.))\";\n    var floatNumber = \"(?:\" + pointFloat + \")\";\n    this.$rules = {\n      \"start\": [{\n        stateName: \"bracketedComment\",\n        onMatch: function onMatch(value, currentState, stack) {\n          stack.unshift(this.next, value.length - 2, currentState);\n          return \"comment\";\n        },\n        regex: /\\-\\-\\[=*\\[/,\n        next: [{\n          onMatch: function onMatch(value, currentState, stack) {\n            if (value.length == stack[1]) {\n              stack.shift();\n              stack.shift();\n              this.next = stack.shift();\n            } else {\n              this.next = \"\";\n            }\n\n            return \"comment\";\n          },\n          regex: /\\]=*\\]/,\n          next: \"start\"\n        }, {\n          defaultToken: \"comment\"\n        }]\n      }, {\n        token: \"comment\",\n        regex: \"\\\\-\\\\-.*$\"\n      }, {\n        stateName: \"bracketedString\",\n        onMatch: function onMatch(value, currentState, stack) {\n          stack.unshift(this.next, value.length, currentState);\n          return \"string.start\";\n        },\n        regex: /\\[=*\\[/,\n        next: [{\n          onMatch: function onMatch(value, currentState, stack) {\n            if (value.length == stack[1]) {\n              stack.shift();\n              stack.shift();\n              this.next = stack.shift();\n            } else {\n              this.next = \"\";\n            }\n\n            return \"string.end\";\n          },\n          regex: /\\]=*\\]/,\n          next: \"start\"\n        }, {\n          defaultToken: \"string\"\n        }]\n      }, {\n        token: \"string\",\n        // \" string\n        regex: '\"(?:[^\\\\\\\\]|\\\\\\\\.)*?\"'\n      }, {\n        token: \"string\",\n        // ' string\n        regex: \"'(?:[^\\\\\\\\]|\\\\\\\\.)*?'\"\n      }, {\n        token: \"constant.numeric\",\n        // float\n        regex: floatNumber\n      }, {\n        token: \"constant.numeric\",\n        // integer\n        regex: integer + \"\\\\b\"\n      }, {\n        token: keywordMapper,\n        regex: \"[a-zA-Z_$][a-zA-Z0-9_$]*\\\\b\"\n      }, {\n        token: \"keyword.operator\",\n        regex: \"\\\\+|\\\\-|\\\\*|\\\\/|%|\\\\#|\\\\^|~|<|>|<=|=>|==|~=|=|\\\\:|\\\\.\\\\.\\\\.|\\\\.\\\\.\"\n      }, {\n        token: \"paren.lparen\",\n        regex: \"[\\\\[\\\\(\\\\{]\"\n      }, {\n        token: \"paren.rparen\",\n        regex: \"[\\\\]\\\\)\\\\}]\"\n      }, {\n        token: \"text\",\n        regex: \"\\\\s+|\\\\w+\"\n      }]\n    };\n    this.normalizeRules();\n  };\n\n  oop.inherits(LuaHighlightRules, TextHighlightRules);\n  exports.LuaHighlightRules = LuaHighlightRules;\n});\nace.define(\"ace/mode/folding/lua\", [\"require\", \"exports\", \"module\", \"ace/lib/oop\", \"ace/mode/folding/fold_mode\", \"ace/range\", \"ace/token_iterator\"], function (acequire, exports, module) {\n  \"use strict\";\n\n  var oop = acequire(\"../../lib/oop\");\n  var BaseFoldMode = acequire(\"./fold_mode\").FoldMode;\n  var Range = acequire(\"../../range\").Range;\n  var TokenIterator = acequire(\"../../token_iterator\").TokenIterator;\n\n  var FoldMode = exports.FoldMode = function () {};\n\n  oop.inherits(FoldMode, BaseFoldMode);\n  (function () {\n    this.foldingStartMarker = /\\b(function|then|do|repeat)\\b|{\\s*$|(\\[=*\\[)/;\n    this.foldingStopMarker = /\\bend\\b|^\\s*}|\\]=*\\]/;\n\n    this.getFoldWidget = function (session, foldStyle, row) {\n      var line = session.getLine(row);\n      var isStart = this.foldingStartMarker.test(line);\n      var isEnd = this.foldingStopMarker.test(line);\n\n      if (isStart && !isEnd) {\n        var match = line.match(this.foldingStartMarker);\n        if (match[1] == \"then\" && /\\belseif\\b/.test(line)) return;\n\n        if (match[1]) {\n          if (session.getTokenAt(row, match.index + 1).type === \"keyword\") return \"start\";\n        } else if (match[2]) {\n          var type = session.bgTokenizer.getState(row) || \"\";\n          if (type[0] == \"bracketedComment\" || type[0] == \"bracketedString\") return \"start\";\n        } else {\n          return \"start\";\n        }\n      }\n\n      if (foldStyle != \"markbeginend\" || !isEnd || isStart && isEnd) return \"\";\n      var match = line.match(this.foldingStopMarker);\n\n      if (match[0] === \"end\") {\n        if (session.getTokenAt(row, match.index + 1).type === \"keyword\") return \"end\";\n      } else if (match[0][0] === \"]\") {\n        var type = session.bgTokenizer.getState(row - 1) || \"\";\n        if (type[0] == \"bracketedComment\" || type[0] == \"bracketedString\") return \"end\";\n      } else return \"end\";\n    };\n\n    this.getFoldWidgetRange = function (session, foldStyle, row) {\n      var line = session.doc.getLine(row);\n      var match = this.foldingStartMarker.exec(line);\n\n      if (match) {\n        if (match[1]) return this.luaBlock(session, row, match.index + 1);\n        if (match[2]) return session.getCommentFoldRange(row, match.index + 1);\n        return this.openingBracketBlock(session, \"{\", row, match.index);\n      }\n\n      var match = this.foldingStopMarker.exec(line);\n\n      if (match) {\n        if (match[0] === \"end\") {\n          if (session.getTokenAt(row, match.index + 1).type === \"keyword\") return this.luaBlock(session, row, match.index + 1);\n        }\n\n        if (match[0][0] === \"]\") return session.getCommentFoldRange(row, match.index + 1);\n        return this.closingBracketBlock(session, \"}\", row, match.index + match[0].length);\n      }\n    };\n\n    this.luaBlock = function (session, row, column) {\n      var stream = new TokenIterator(session, row, column);\n      var indentKeywords = {\n        \"function\": 1,\n        \"do\": 1,\n        \"then\": 1,\n        \"elseif\": -1,\n        \"end\": -1,\n        \"repeat\": 1,\n        \"until\": -1\n      };\n      var token = stream.getCurrentToken();\n      if (!token || token.type != \"keyword\") return;\n      var val = token.value;\n      var stack = [val];\n      var dir = indentKeywords[val];\n      if (!dir) return;\n      var startColumn = dir === -1 ? stream.getCurrentTokenColumn() : session.getLine(row).length;\n      var startRow = row;\n      stream.step = dir === -1 ? stream.stepBackward : stream.stepForward;\n\n      while (token = stream.step()) {\n        if (token.type !== \"keyword\") continue;\n        var level = dir * indentKeywords[token.value];\n\n        if (level > 0) {\n          stack.unshift(token.value);\n        } else if (level <= 0) {\n          stack.shift();\n          if (!stack.length && token.value != \"elseif\") break;\n          if (level === 0) stack.unshift(token.value);\n        }\n      }\n\n      var row = stream.getCurrentTokenRow();\n      if (dir === -1) return new Range(row, session.getLine(row).length, startRow, startColumn);else return new Range(startRow, startColumn, row, stream.getCurrentTokenColumn());\n    };\n  }).call(FoldMode.prototype);\n});\nace.define(\"ace/mode/lua\", [\"require\", \"exports\", \"module\", \"ace/lib/oop\", \"ace/mode/text\", \"ace/mode/lua_highlight_rules\", \"ace/mode/folding/lua\", \"ace/range\", \"ace/worker/worker_client\"], function (acequire, exports, module) {\n  \"use strict\";\n\n  var oop = acequire(\"../lib/oop\");\n  var TextMode = acequire(\"./text\").Mode;\n  var LuaHighlightRules = acequire(\"./lua_highlight_rules\").LuaHighlightRules;\n  var LuaFoldMode = acequire(\"./folding/lua\").FoldMode;\n  var Range = acequire(\"../range\").Range;\n  var WorkerClient = acequire(\"../worker/worker_client\").WorkerClient;\n\n  var Mode = function Mode() {\n    this.HighlightRules = LuaHighlightRules;\n    this.foldingRules = new LuaFoldMode();\n    this.$behaviour = this.$defaultBehaviour;\n  };\n\n  oop.inherits(Mode, TextMode);\n  (function () {\n    this.lineCommentStart = \"--\";\n    this.blockComment = {\n      start: \"--[\",\n      end: \"]--\"\n    };\n    var indentKeywords = {\n      \"function\": 1,\n      \"then\": 1,\n      \"do\": 1,\n      \"else\": 1,\n      \"elseif\": 1,\n      \"repeat\": 1,\n      \"end\": -1,\n      \"until\": -1\n    };\n    var outdentKeywords = [\"else\", \"elseif\", \"end\", \"until\"];\n\n    function getNetIndentLevel(tokens) {\n      var level = 0;\n\n      for (var i = 0; i < tokens.length; i++) {\n        var token = tokens[i];\n\n        if (token.type == \"keyword\") {\n          if (token.value in indentKeywords) {\n            level += indentKeywords[token.value];\n          }\n        } else if (token.type == \"paren.lparen\") {\n          level += token.value.length;\n        } else if (token.type == \"paren.rparen\") {\n          level -= token.value.length;\n        }\n      }\n\n      if (level < 0) {\n        return -1;\n      } else if (level > 0) {\n        return 1;\n      } else {\n        return 0;\n      }\n    }\n\n    this.getNextLineIndent = function (state, line, tab) {\n      var indent = this.$getIndent(line);\n      var level = 0;\n      var tokenizedLine = this.getTokenizer().getLineTokens(line, state);\n      var tokens = tokenizedLine.tokens;\n\n      if (state == \"start\") {\n        level = getNetIndentLevel(tokens);\n      }\n\n      if (level > 0) {\n        return indent + tab;\n      } else if (level < 0 && indent.substr(indent.length - tab.length) == tab) {\n        if (!this.checkOutdent(state, line, \"\\n\")) {\n          return indent.substr(0, indent.length - tab.length);\n        }\n      }\n\n      return indent;\n    };\n\n    this.checkOutdent = function (state, line, input) {\n      if (input != \"\\n\" && input != \"\\r\" && input != \"\\r\\n\") return false;\n      if (line.match(/^\\s*[\\)\\}\\]]$/)) return true;\n      var tokens = this.getTokenizer().getLineTokens(line.trim(), state).tokens;\n      if (!tokens || !tokens.length) return false;\n      return tokens[0].type == \"keyword\" && outdentKeywords.indexOf(tokens[0].value) != -1;\n    };\n\n    this.autoOutdent = function (state, session, row) {\n      var prevLine = session.getLine(row - 1);\n      var prevIndent = this.$getIndent(prevLine).length;\n      var prevTokens = this.getTokenizer().getLineTokens(prevLine, \"start\").tokens;\n      var tabLength = session.getTabString().length;\n      var expectedIndent = prevIndent + tabLength * getNetIndentLevel(prevTokens);\n      var curIndent = this.$getIndent(session.getLine(row)).length;\n\n      if (curIndent <= expectedIndent) {\n        return;\n      }\n\n      session.outdentRows(new Range(row, 0, row + 2, 0));\n    };\n\n    this.createWorker = function (session) {\n      var worker = new WorkerClient([\"ace\"], require(\"../worker/lua\"), \"Worker\");\n      worker.attachToDocument(session.getDocument());\n      worker.on(\"annotate\", function (e) {\n        session.setAnnotations(e.data);\n      });\n      worker.on(\"terminate\", function () {\n        session.clearAnnotations();\n      });\n      return worker;\n    };\n\n    this.$id = \"ace/mode/lua\";\n  }).call(Mode.prototype);\n  exports.Mode = Mode;\n});"],"sourceRoot":""}