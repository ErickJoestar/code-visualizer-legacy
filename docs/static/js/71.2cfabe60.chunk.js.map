{"version":3,"sources":["../node_modules/brace/mode/latex.js"],"names":["ace","define","acequire","exports","module","oop","TextHighlightRules","LatexHighlightRules","this","$rules","token","regex","next","defaultToken","normalizeRules","inherits","BaseFoldMode","FoldMode","Range","TokenIterator","keywordLevels","foldingStartMarker","foldingStopMarker","getFoldWidgetRange","session","foldStyle","row","match","line","doc","getLine","exec","latexBlock","length","latexSection","openingBracketBlock","index","closingBracketBlock","column","returnRange","keywords","stream","getCurrentToken","type","dir","value","getType","stepForward","stepBackward","stack","startColumn","getCurrentTokenColumn","startRow","step","level","unshift","shift","getCurrentTokenRange","getCurrentTokenRow","startLevel","stackDepth","endRow","test","call","prototype","TextMode","Mode","CstyleBehaviour","LatexFoldMode","HighlightRules","foldingRules","$behaviour","braces","lineCommentStart","$id","getMatching","undefined","selection","lead","startToken","getTokenAt"],"mappings":"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","file":"static/js/71.2cfabe60.chunk.js","sourcesContent":["ace.define(\"ace/mode/latex_highlight_rules\", [\"require\", \"exports\", \"module\", \"ace/lib/oop\", \"ace/mode/text_highlight_rules\"], function (acequire, exports, module) {\n  \"use strict\";\n\n  var oop = acequire(\"../lib/oop\");\n  var TextHighlightRules = acequire(\"./text_highlight_rules\").TextHighlightRules;\n\n  var LatexHighlightRules = function LatexHighlightRules() {\n    this.$rules = {\n      \"start\": [{\n        token: \"comment\",\n        regex: \"%.*$\"\n      }, {\n        token: [\"keyword\", \"lparen\", \"variable.parameter\", \"rparen\", \"lparen\", \"storage.type\", \"rparen\"],\n        regex: \"(\\\\\\\\(?:documentclass|usepackage|input))(?:(\\\\[)([^\\\\]]*)(\\\\]))?({)([^}]*)(})\"\n      }, {\n        token: [\"keyword\", \"lparen\", \"variable.parameter\", \"rparen\"],\n        regex: \"(\\\\\\\\(?:label|v?ref|cite(?:[^{]*)))(?:({)([^}]*)(}))?\"\n      }, {\n        token: [\"storage.type\", \"lparen\", \"variable.parameter\", \"rparen\"],\n        regex: \"(\\\\\\\\begin)({)(verbatim)(})\",\n        next: \"verbatim\"\n      }, {\n        token: [\"storage.type\", \"lparen\", \"variable.parameter\", \"rparen\"],\n        regex: \"(\\\\\\\\begin)({)(lstlisting)(})\",\n        next: \"lstlisting\"\n      }, {\n        token: [\"storage.type\", \"lparen\", \"variable.parameter\", \"rparen\"],\n        regex: \"(\\\\\\\\(?:begin|end))({)([\\\\w*]*)(})\"\n      }, {\n        token: \"storage.type\",\n        regex: /\\\\verb\\b\\*?/,\n        next: [{\n          token: [\"keyword.operator\", \"string\", \"keyword.operator\"],\n          regex: \"(.)(.*?)(\\\\1|$)|\",\n          next: \"start\"\n        }]\n      }, {\n        token: \"storage.type\",\n        regex: \"\\\\\\\\[a-zA-Z]+\"\n      }, {\n        token: \"lparen\",\n        regex: \"[[({]\"\n      }, {\n        token: \"rparen\",\n        regex: \"[\\\\])}]\"\n      }, {\n        token: \"constant.character.escape\",\n        regex: \"\\\\\\\\[^a-zA-Z]?\"\n      }, {\n        token: \"string\",\n        regex: \"\\\\${1,2}\",\n        next: \"equation\"\n      }],\n      \"equation\": [{\n        token: \"comment\",\n        regex: \"%.*$\"\n      }, {\n        token: \"string\",\n        regex: \"\\\\${1,2}\",\n        next: \"start\"\n      }, {\n        token: \"constant.character.escape\",\n        regex: \"\\\\\\\\(?:[^a-zA-Z]|[a-zA-Z]+)\"\n      }, {\n        token: \"error\",\n        regex: \"^\\\\s*$\",\n        next: \"start\"\n      }, {\n        defaultToken: \"string\"\n      }],\n      \"verbatim\": [{\n        token: [\"storage.type\", \"lparen\", \"variable.parameter\", \"rparen\"],\n        regex: \"(\\\\\\\\end)({)(verbatim)(})\",\n        next: \"start\"\n      }, {\n        defaultToken: \"text\"\n      }],\n      \"lstlisting\": [{\n        token: [\"storage.type\", \"lparen\", \"variable.parameter\", \"rparen\"],\n        regex: \"(\\\\\\\\end)({)(lstlisting)(})\",\n        next: \"start\"\n      }, {\n        defaultToken: \"text\"\n      }]\n    };\n    this.normalizeRules();\n  };\n\n  oop.inherits(LatexHighlightRules, TextHighlightRules);\n  exports.LatexHighlightRules = LatexHighlightRules;\n});\nace.define(\"ace/mode/folding/latex\", [\"require\", \"exports\", \"module\", \"ace/lib/oop\", \"ace/mode/folding/fold_mode\", \"ace/range\", \"ace/token_iterator\"], function (acequire, exports, module) {\n  \"use strict\";\n\n  var oop = acequire(\"../../lib/oop\");\n  var BaseFoldMode = acequire(\"./fold_mode\").FoldMode;\n  var Range = acequire(\"../../range\").Range;\n  var TokenIterator = acequire(\"../../token_iterator\").TokenIterator;\n  var keywordLevels = {\n    \"\\\\subparagraph\": 1,\n    \"\\\\paragraph\": 2,\n    \"\\\\subsubsubsection\": 3,\n    \"\\\\subsubsection\": 4,\n    \"\\\\subsection\": 5,\n    \"\\\\section\": 6,\n    \"\\\\chapter\": 7,\n    \"\\\\part\": 8,\n    \"\\\\begin\": 9,\n    \"\\\\end\": 10\n  };\n\n  var FoldMode = exports.FoldMode = function () {};\n\n  oop.inherits(FoldMode, BaseFoldMode);\n  (function () {\n    this.foldingStartMarker = /^\\s*\\\\(begin)|\\s*\\\\(part|chapter|(?:sub)*(?:section|paragraph))\\b|{\\s*$/;\n    this.foldingStopMarker = /^\\s*\\\\(end)\\b|^\\s*}/;\n\n    this.getFoldWidgetRange = function (session, foldStyle, row) {\n      var line = session.doc.getLine(row);\n      var match = this.foldingStartMarker.exec(line);\n\n      if (match) {\n        if (match[1]) return this.latexBlock(session, row, match[0].length - 1);\n        if (match[2]) return this.latexSection(session, row, match[0].length - 1);\n        return this.openingBracketBlock(session, \"{\", row, match.index);\n      }\n\n      var match = this.foldingStopMarker.exec(line);\n\n      if (match) {\n        if (match[1]) return this.latexBlock(session, row, match[0].length - 1);\n        return this.closingBracketBlock(session, \"}\", row, match.index + match[0].length);\n      }\n    };\n\n    this.latexBlock = function (session, row, column, returnRange) {\n      var keywords = {\n        \"\\\\begin\": 1,\n        \"\\\\end\": -1\n      };\n      var stream = new TokenIterator(session, row, column);\n      var token = stream.getCurrentToken();\n      if (!token || !(token.type == \"storage.type\" || token.type == \"constant.character.escape\")) return;\n      var val = token.value;\n      var dir = keywords[val];\n\n      var getType = function getType() {\n        var token = stream.stepForward();\n        var type = token.type == \"lparen\" ? stream.stepForward().value : \"\";\n\n        if (dir === -1) {\n          stream.stepBackward();\n          if (type) stream.stepBackward();\n        }\n\n        return type;\n      };\n\n      var stack = [getType()];\n      var startColumn = dir === -1 ? stream.getCurrentTokenColumn() : session.getLine(row).length;\n      var startRow = row;\n      stream.step = dir === -1 ? stream.stepBackward : stream.stepForward;\n\n      while (token = stream.step()) {\n        if (!token || !(token.type == \"storage.type\" || token.type == \"constant.character.escape\")) continue;\n        var level = keywords[token.value];\n        if (!level) continue;\n        var type = getType();\n        if (level === dir) stack.unshift(type);else if (stack.shift() !== type || !stack.length) break;\n      }\n\n      if (stack.length) return;\n\n      if (dir == 1) {\n        stream.stepBackward();\n        stream.stepBackward();\n      }\n\n      if (returnRange) return stream.getCurrentTokenRange();\n      var row = stream.getCurrentTokenRow();\n      if (dir === -1) return new Range(row, session.getLine(row).length, startRow, startColumn);else return new Range(startRow, startColumn, row, stream.getCurrentTokenColumn());\n    };\n\n    this.latexSection = function (session, row, column) {\n      var stream = new TokenIterator(session, row, column);\n      var token = stream.getCurrentToken();\n      if (!token || token.type != \"storage.type\") return;\n      var startLevel = keywordLevels[token.value] || 0;\n      var stackDepth = 0;\n      var endRow = row;\n\n      while (token = stream.stepForward()) {\n        if (token.type !== \"storage.type\") continue;\n        var level = keywordLevels[token.value] || 0;\n\n        if (level >= 9) {\n          if (!stackDepth) endRow = stream.getCurrentTokenRow() - 1;\n          stackDepth += level == 9 ? 1 : -1;\n          if (stackDepth < 0) break;\n        } else if (level >= startLevel) break;\n      }\n\n      if (!stackDepth) endRow = stream.getCurrentTokenRow() - 1;\n\n      while (endRow > row && !/\\S/.test(session.getLine(endRow))) {\n        endRow--;\n      }\n\n      return new Range(row, session.getLine(row).length, endRow, session.getLine(endRow).length);\n    };\n  }).call(FoldMode.prototype);\n});\nace.define(\"ace/mode/latex\", [\"require\", \"exports\", \"module\", \"ace/lib/oop\", \"ace/mode/text\", \"ace/mode/latex_highlight_rules\", \"ace/mode/behaviour/cstyle\", \"ace/mode/folding/latex\"], function (acequire, exports, module) {\n  \"use strict\";\n\n  var oop = acequire(\"../lib/oop\");\n  var TextMode = acequire(\"./text\").Mode;\n  var LatexHighlightRules = acequire(\"./latex_highlight_rules\").LatexHighlightRules;\n  var CstyleBehaviour = acequire(\"./behaviour/cstyle\").CstyleBehaviour;\n  var LatexFoldMode = acequire(\"./folding/latex\").FoldMode;\n\n  var Mode = function Mode() {\n    this.HighlightRules = LatexHighlightRules;\n    this.foldingRules = new LatexFoldMode();\n    this.$behaviour = new CstyleBehaviour({\n      braces: true\n    });\n  };\n\n  oop.inherits(Mode, TextMode);\n  (function () {\n    this.type = \"text\";\n    this.lineCommentStart = \"%\";\n    this.$id = \"ace/mode/latex\";\n\n    this.getMatching = function (session, row, column) {\n      if (row == undefined) row = session.selection.lead;\n\n      if (typeof row == \"object\") {\n        column = row.column;\n        row = row.row;\n      }\n\n      var startToken = session.getTokenAt(row, column);\n      if (!startToken) return;\n\n      if (startToken.value == \"\\\\begin\" || startToken.value == \"\\\\end\") {\n        return this.foldingRules.latexBlock(session, row, column, true);\n      }\n    };\n  }).call(Mode.prototype);\n  exports.Mode = Mode;\n});"],"sourceRoot":""}